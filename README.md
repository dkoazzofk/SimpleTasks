# Список задач

:one: **Guess the Number (Угадай число)** :ballot_box_with_check:

:two: **To-Do-List (Список дел)** :ballot_box_with_check:

:three: **Unit Converter (Преобразователь единиц измерения)** :ballot_box_with_check:

:four: **TCP echoClientServer (TCP Эхо Клинет Сервер)** :ballot_box_with_check:

:five: **UDP echoClientServer (UDP Эхо Клиент Сервер)** :ballot_box_with_check:

:six: **Fork** :ballot_box_with_check:

:seven: **Pthread** :ballot_box_with_check:

:eight: **Pipe** :ballot_box_with_check:

## TCP Echo Client Server
**Установка опции на незамедлительное освобождение порта после использования в server.c**
```
opt = 1;
setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
```
Переменная **opt** нужна для храненния значения опции **SO_REUSEADDR**. Функция **setsockopt** ожидает указатель на значение.

Данную опцию нужно устанавливать **ДО** вызова bind(), иначе она не будет иметь эффекта.

**Использование двух сокетов**
```
while(1){
    int valread = read(client_socket, buffer, 1024);
    printf("Messager from client: %s\n", buffer);

    send(client_socket, buffer, strlen(buffer), 0);
    printf("Message was sended\n"); 
}
```
В коде **server.c** используется два сокета, такие как: sockfd и client_socket.

sockfd является **"слушающим"** сокетом, его единственная задача - **принимать новые соединения** через accept()

accept() возвращает совершенно новый сокет **client_socket**, который:
1. Связан с конкретным клиентом.
2. Содержит уникальный идентификатор соединения.
3. Используется для всех операций ввода-вывода с этим клиентом.

## Fork

## Task 1: Простое создание процесса

**Цель:** Проверить, что программа корректно создает дочерний процесс.

**Требования:**

1. Родительский процесс должен вывести свой PID и PID дочернего процесса.
2. Дочерний процесс должен вывести свой PID и PPID (родительский PID).
3. Оба процесса должны завершиться без ошибок.

**Ожидаемый вывод (пример):**

    Родительский процесс: PID = X, Дочерний PID = Y

    Дочерний процесс: PID = Y, PPID = X

## Task 2: Разветвление процессов

**Цель:** Создать несколько дочерних процессов и проверить их выполнение.

**Требования:**

1. Родительский процесс создает 3 дочерних процесса.
2. Каждый дочерний процесс выводит свой PID и порядковый номер (1, 2, 3).
3. Родительский процесс дожидается завершения всех дочерних процессов.

**Ожидаемый вывод (пример):**

    Родительский процесс: PID = X

    Дочерний 1: PID = Y1

    Дочерний 2: PID = Y2

    Дочерний 3: PID = Y3

    Родительский процесс: все дети завершены.

## Task 3: Разделение работы между процессами

**Цель:** Проверить, что родительский и дочерний процесс выполняют разные задачи.

**Требования:**

1. Родительский процесс вычисляет сумму четных чисел от 1 до N.
2. Дочерний процесс вычисляет сумму нечетных чисел от 1 до N.
3. Каждый процесс выводит свой результат.

**Ожидаемый вывод (пример, N = 10):**

    Родитель: Сумма четных = 30

    Дочерний: Сумма нечетных = 25

## Task 4: Проверка на зомби-процессы

**Цель:** Убедиться, что программа не оставляет зомби-процессы.

**Требования:**

1. Родительский процесс создает дочерний и завершается раньше него.
2. Дочерний процесс должен стать orphan и быть усыновленным init (PPID = 1).
3. Проверить через ps aux | grep <PID> в другом терминале, что нет зомби.

**Ожидаемое поведение:**

    Дочерний процесс завершается самостоятельно.

    В списке процессов нет <defunct>

## Task 5: Цепочка процессов

**Цель:** Создать цепочку из процессов (каждый создает одного потомка).

**Требования:**

1. Процесс 1 создает процесс 2, процесс 2 создает процесс 3 и т. д. (всего 3 уровня).
2. Каждый процесс выводит свой PID и уровень в цепочке.
3. Родительские процессы должны дожидаться завершения своих детей.

**Ожидаемый вывод (пример):**

    Уровень 1: PID = X  

    Уровень 2: PID = Y  

    Уровень 3: PID = Z  

## Pthread

## Task 1: Создание и завершение потоков

Напишите программу, которая создает 5 потоков, каждый из которых выводит свой идентификатор (tid) и завершается. 

Основной поток должен дождаться завершения всех созданных потоков с помощью pthread_join и затем вывести сообщение о завершении работы.

**Пример вывода:**

    Поток 1: tid = 12345  

    Поток 2: tid = 12346  

    Все потоки завершили работу.  

## Task 2: Параллельное вычисление суммы массива

**Цель:** Научиться разделять работу между потоками и синхронизировать доступ к общим данным.
Условие:
1. Дан массив из 10 целых чисел.
2. Необходимо разбить массив на 2 частей.
3. Каждый поток вычисляет сумму своей части массива.
4. Главный поток собирает результаты и выводит общую сумму.

**Требования:**

Использовать мьютекс для защиты общей суммы.

## Task 3: Ожидание с условными переменными

**Цель:** Реализуйте паттерн "Производитель-Потребитель".

**Требования:**
1. Один поток ("производитель") записывает числа в буфер (массив размера 5).
2. Другой поток ("потребитель") читает числа из буфера.
3. Использовать условные переменные (pthread_cond_t).
4. Использовать мьютекс.

**Пример вывода:**

    Производитель записал: 42  
    Потребитель прочитал: 42  

## Task 4: Параллельное вычисление с использованием барьера (pthread_barrier)

**Условие:** Необходимо реализовать программу, в которой несколько потоков параллельно заполняют массив случайными числами, 
а затем синхронизируются с помощью барьера, после чего главный поток находит сумму всех элементов массива.

**Требования:**
1. Создать N потоков (например, 4).
2. Каждый поток заполняет свою часть массива случайными числами.
3. После заполнения массива все потоки должны ожидать у барьера, пока все не закончат работу.
4. Главный поток (после завершения всех потоков) вычисляет сумму элементов массива.

## Pipe

## Task 1: Простейший pipe (родитель → ребёнок)

**Задача:** Создать pipe, записать строку из родительского процесса и прочитать её в дочернем.

**Примерный вывод:**

    Parent writes: Hello, child!  

    Child reads: Hello, child!  

## Task 2: Pipe с двусторонней связью (родитель ↔ ребёнок)

**Задача:**
Создать два pipe:
1. Один для передачи данных от родителя к ребёнку.
2. Второй — от ребёнка к родителю.

## Task 3: Подсчёт символов через pipe

**Задача:**
1. Родительский процесс отправляет строку, дочерний — подсчитывает количество символов и возвращает результат.

**Примерный вывод:**

    Parent sends: "Hello"  

    Child counts: 5 characters  

## Task 4: Конвейер (pipeline) из нескольких процессов

**Задача:**
Создать цепочку процессов (A → B → C), где:
1. Процесс A пишет данные в pipe.
2. Процесс B читает, обрабатывает (например, переводит в верхний регистр) и передаёт дальше.
3. Процесс C выводит результат.

**Примерный вывод:**

    Input: "hello"  

    Process B converts to "HELLO"  

    Process C prints: "HELLO"  

## MSGQueue

# Task 1: Простая отправка и получение сообщения

**Цель:**
Понять базовый механизм работы msgsnd() и msgrcv().

**Задача:**
Напишите две программы:
1. sender.c — создает очередь сообщений и отправляет одно сообщение.
2. receiver.c — получает это сообщение и выводит его на экран.

**Пример сообщения:**
    "Hello from sender!"  

# Task 2: Обмен несколькими сообщениями

**Цель:**
Разобраться с приоритетами сообщений (mtype).

**Задача:**
Модифицируйте предыдущие программы так, чтобы:
1. sender.c отправлял 3 сообщения с разными типами (например, 1, 2, 3).
2. receiver.c принимал сообщения в порядке, обратном их приоритету (сначала тип 3, потом 2, затем 1).